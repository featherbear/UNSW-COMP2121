<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Introduction - COMP2121 Musings</title><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta name=theme-color content=#f8f5ec><meta name=msapplication-navbutton-color content=#f8f5ec><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=#f8f5ec><meta name=author content=z5206677><meta name=description content="USER PERSPECTIVE  Atmel AVR  8-bit RISC Architecture  Reduced Instruction Set Computer Most instructions have a fixed length of 16-bits Most instructions take 1 clock cycle to execute  Load-store memory access architecture  All calculations performed on registers  Two stage instruciton pipelining Internal program memory memory and data memory Peripherals - PWM, ADC, EEPROM, UART  Registers  32 8-bit registers :: R0 -&amp;gt; R31 Most operations performed within the register Some instructions only work on R16 -&amp;gt; R31 (encoding limitation)  Instruction :: Load Immediate  ldi Rd, #number* ldi R16, 25 -&amp;gt; Load the integer 25 into register 16  ldi 1110 kkkk dddd kkkk"><meta name=keywords content=Hugo,theme,even><meta name=generator content="Hugo 0.58.2 with theme even"><link rel=canonical href=../../post/introduction/><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../manifest.json><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><link href=../../dist/even.c2a46f00.min.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=../../css/typedjs.shortcode.css><meta property=og:title content=Introduction><meta property=og:description content="USER PERSPECTIVE  Atmel AVR  8-bit RISC Architecture  Reduced Instruction Set Computer Most instructions have a fixed length of 16-bits Most instructions take 1 clock cycle to execute  Load-store memory access architecture  All calculations performed on registers  Two stage instruciton pipelining Internal program memory memory and data memory Peripherals - PWM, ADC, EEPROM, UART  Registers  32 8-bit registers :: R0 -&gt; R31 Most operations performed within the register Some instructions only work on R16 -&gt; R31 (encoding limitation)  Instruction :: Load Immediate  ldi Rd, #number* ldi R16, 25 -&gt; Load the integer 25 into register 16  ldi 1110 kkkk dddd kkkk"><meta property=og:type content=article><meta property=og:url content=/post/introduction/><meta property=article:published_time content=2020-02-18T15:12:39+11:00><meta property=article:modified_time content=2020-02-18T15:12:39+11:00><meta itemprop=name content=Introduction><meta itemprop=description content="USER PERSPECTIVE  Atmel AVR  8-bit RISC Architecture  Reduced Instruction Set Computer Most instructions have a fixed length of 16-bits Most instructions take 1 clock cycle to execute  Load-store memory access architecture  All calculations performed on registers  Two stage instruciton pipelining Internal program memory memory and data memory Peripherals - PWM, ADC, EEPROM, UART  Registers  32 8-bit registers :: R0 -&gt; R31 Most operations performed within the register Some instructions only work on R16 -&gt; R31 (encoding limitation)  Instruction :: Load Immediate  ldi Rd, #number* ldi R16, 25 -&gt; Load the integer 25 into register 16  ldi 1110 kkkk dddd kkkk"><meta itemprop=datePublished content=2020-02-18T15:12:39&#43;11:00><meta itemprop=dateModified content=2020-02-18T15:12:39&#43;11:00><meta itemprop=wordCount content=683><meta itemprop=keywords content><meta name=twitter:card content=summary><meta name=twitter:title content=Introduction><meta name=twitter:description content="USER PERSPECTIVE  Atmel AVR  8-bit RISC Architecture  Reduced Instruction Set Computer Most instructions have a fixed length of 16-bits Most instructions take 1 clock cycle to execute  Load-store memory access architecture  All calculations performed on registers  Two stage instruciton pipelining Internal program memory memory and data memory Peripherals - PWM, ADC, EEPROM, UART  Registers  32 8-bit registers :: R0 -&gt; R31 Most operations performed within the register Some instructions only work on R16 -&gt; R31 (encoding limitation)  Instruction :: Load Immediate  ldi Rd, #number* ldi R16, 25 -&gt; Load the integer 25 into register 16  ldi 1110 kkkk dddd kkkk"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=../../ class=logo>COMP2121 Musings</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=../../><li class=mobile-menu-item>Home</li></a><a href=https://github.com/featherbear/UNSW-COMP2121><li class=mobile-menu-item>GitHub</li></a><a href=../../categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=../../ class=logo>COMP2121 Musings</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=../../>Home</a></li><li class=menu-item><a class=menu-item-link href=https://github.com/featherbear/UNSW-COMP2121>GitHub</a></li><li class=menu-item><a class=menu-item-link href=../../categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Introduction</h1><div class=post-meta><span class=post-time>2020-02-18</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#atmel-avr>Atmel AVR</a><ul><li><a href=#registers>Registers</a></li><li><a href=#instruction-load-immediate>Instruction :: Load Immediate</a></li><li><a href=#instruction-multiply>Instruction :: Multiply</a></li><li><a href=#arithmetic-calculation>Arithmetic Calculation</a></li><li><a href=#registers-1>Registers</a><ul><li><a href=#i-o-registers>I/O Registers</a><ul><li><a href=#the-status-register-sreg>The Status Register (SREG)</a></li></ul></li><li><a href=#address-spaces>Address Spaces</a></li></ul></li><li><a href=#data-memory-space>Data Memory Space</a></li><li><a href=#program-memory-space>Program Memory Space</a></li><li><a href=#eeprom>EEPROM</a></li><li><a href=#avr-instruction-format>AVR Instruction Format</a><ul><li><a href=#instruction-add>Instruction :: Add</a></li><li><a href=#instruction-unconditional-branch-32-bit-long>Instruction :: Unconditional Branch -&gt; 32 bit long</a></li><li><a href=#instruction-conditional-branch>Instruction: Conditional Branch</a></li></ul></li></ul></li><li><a href=#addressing-modes>Addressing Modes</a><ul><li><a href=#instruction-compare>Instruction :: Compare</a></li><li><a href=#instruction-compare-immediate>Instruction :: Compare Immediate</a></li><li><a href=#instruction-relative-jump>Instruction :: Relative Jump</a></li></ul></li></ul></nav></div></div><div class=post-content><ul><li>USER PERSPECTIVE</li></ul><h1 id=atmel-avr>Atmel AVR</h1><ul><li>8-bit RISC Architecture<ul><li>Reduced Instruction Set Computer</li><li>Most instructions have a fixed length of 16-bits</li><li>Most instructions take 1 clock cycle to execute</li></ul></li><li>Load-store memory access architecture<ul><li>All calculations performed on registers</li></ul></li><li>Two stage instruciton pipelining</li><li>Internal program memory memory and data memory</li><li>Peripherals - PWM, ADC, EEPROM, UART</li></ul><h2 id=registers>Registers</h2><ul><li>32 8-bit registers :: <code>R0</code> -&gt; <code>R31</code></li><li>Most operations performed within the register</li><li>Some instructions only work on <code>R16</code> -&gt; <code>R31</code> (encoding limitation)</li></ul><h2 id=instruction-load-immediate>Instruction :: Load Immediate</h2><ul><li><code>ldi</code> <code>Rd</code>, <code>#number</code>*</li><li><code>ldi R16, 25</code> -&gt; Load the integer 25 into register 16</li></ul><p><code>ldi 1110 kkkk dddd kkkk</code></p><p>In the instruction set for ldi, there are only 4 bits available for the register location.
We can therefore only have 2^4 -&gt; 16 locations.<br>AVR is developed such that these locations are respective of the upper 16 register (R16-&gt;R31).</p><h2 id=instruction-multiply>Instruction :: Multiply</h2><p><code>mul Rd, Rr</code> :: r1:r0 &lt;- Rr*Rd
Multiply the byte of register <code>Rd</code> by the byte of register <code>Rr</code>, and store the results in <code>r1</code> and <code>r0</code>.<br><code>r1</code> contains the first 8 bits (HI / MSB)<br><code>r0</code> contains the last 8 bits (LO / LSB)</p><p>Multiplying takes 2 cycles</p><h2 id=arithmetic-calculation>Arithmetic Calculation</h2><p>Consider having to write the following equation in assembly language: <code>z = 2x - xy - x^2</code></p><p>Where all data including products from multiplications are 8-bit unsigned numbers.<br><code>x</code>, <code>y</code>, <code>z</code> are stored in registers <code>r2</code>, <code>r3</code>, <code>r4</code>.</p><blockquote><p>A 2-bit number x 2-bit number = a 4-bit number<br>A 8-bit number x 8-bit number = a 18-bit number</p></blockquote><p><strong>But</strong>, <code>z</code> is 8-bits, not 16!<br>For now assume <code>x</code>, <code>y</code> &lt; 16 (4-bits)</p><p>Could improve by factoring out <code>x</code>, removing the number of multiplications.<br>Could use <code>r4</code> instead of <code>r5</code> for temporary variables.</p><h2 id=registers-1>Registers</h2><p>X Register - R27:R26
Y Register - R29:R28
Z Register - R31:R30</p><p>Typically used as pointers (16 bits)</p><p>Special registers for iput and output</p><h3 id=i-o-registers>I/O Registers</h3><ul><li>64+416 8-bit registers</li><li>Used for input/output instructions</li><li>The first 64 IO registers have two addresses :: I/O addresses and memory addresses</li></ul><h4 id=the-status-register-sreg>The Status Register (SREG)</h4><p>The Status Register is an 8-bit wide register that keeps track of the previous arithmetic instruction.<br>Automatically updated</p><table><thead><tr><th align=center>I</th><th align=center>T</th><th align=center>H</th><th align=center>S</th><th align=center>V</th><th align=center>N</th><th align=center>Z</th><th align=center>C</th></tr></thead><tbody><tr><td align=center>Global Interrupt Enable</td><td align=center></td><td align=center></td><td align=center></td><td align=center></td><td align=center></td><td align=center></td><td align=center></td></tr></tbody></table><p>I -<br>T -<br>H - Half Carry<br>S - Sign Bit<br>V -<br>N -<br>Z - Zero Result<br>C - Carry</p><h3 id=address-spaces>Address Spaces</h3><p>Data memory</p><p>Program Memory - Program</p><p>EEPROM Memory - ie startup / bootloader
-&gt; Electrically Erasable Programmable ROM</p><hr><h2 id=data-memory-space>Data Memory Space</h2><ul><li><code>r0</code> mapped to data memory 0x0000</li><li><p><code>r31</code> mapped to data memory 0x001F</p></li><li><p>The first 32 + 46+416 == 512 registers are all internal</p></li><li><p>Highest memory location is defined as <code>RAMEND</code></p></li></ul><h2 id=program-memory-space>Program Memory Space</h2><ul><li>16-bit flash memory</li></ul><p>TODO: Notes</p><h2 id=eeprom>EEPROM</h2><p>TODO: Notes</p><h2 id=avr-instruction-format>AVR Instruction Format</h2><p><code>brge</code> - BRanch if Greater than or Equal to. -&gt; Uses the status registers</p><p>32 bit instructions</p><p>lds Rd, k
^ 16
^ 5</p><p>Loads 1 byte from the SRAM</p><h3 id=instruction-add>Instruction :: Add</h3><p><code>add Rd, Rr</code></p><p>0001 01rd dddd rrrr</p><h3 id=instruction-unconditional-branch-32-bit-long>Instruction :: Unconditional Branch -&gt; 32 bit long</h3><p><code>jmp k</code></p><p>PC &lt;- k</p><p>1001 010k kkkk 110k kkkk kkkk kkkk kkkk</p><h3 id=instruction-conditional-branch>Instruction: Conditional Branch</h3><p>breq k</p><p><code>-64 &lt;= k &lt; 63</code></p><p>1111 00kk kkkk k001</p><p>// TODO: Two&rsquo;s complement</p><p>&ndash; LOGIC - and, or, xor
&ndash; SHIFT - lsl Rd</p><hr><p>GP &ndash; mov</p><p>stack &ndash; push Rr, pop Rd</p><p>Memory &ndash; ld Rd, X, st X, Rr (address is in register X)</p><p>sbic - test a bit in a register, skip next instruction if true</p><p>rjmpdest
rcall
ret</p><p>Program memory - lpm</p><hr><p>///</p><h1 id=addressing-modes>Addressing Modes</h1><p>Immediate
Register direct
Memory related addressing mode
* Data memory
* DIrect
* Indirect
* Indirect wiht displacement
* Indirect with pre-decrement
* Indirect wiht pre-increment</p><p>Indirect addressing with displacement</p><p>-&gt; Data memory addressfrom (Y,Z)+q
Useful for arrays</p><p>std Y+, r14
std Y, r14</p><p>// TODO: ???</p><hr><p>icall -&gt; go to location Z</p><p>&ndash;</p><p>&ndash;</p><h2 id=instruction-compare>Instruction :: Compare</h2><p><code>cp Rd, Rr</code></p><p><code>Rd - Rr</code> -&gt; Store into status register</p><h2 id=instruction-compare-immediate>Instruction :: Compare Immediate</h2><h2 id=instruction-relative-jump>Instruction :: Relative Jump</h2></div><footer class=post-footer><nav class=post-nav></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:z5206677@student.unsw.edu.au class="iconfont icon-email" title=email></a><a href=https://www.linkedin.com/in/andrewjinmengwong/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/featherbear class="iconfont icon-github" title=github></a><a href=https://www.instagram.com/_andrewjwong/ class="iconfont icon-instagram" title=instagram></a><a href=../../index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Andrew Wong (z5206677)</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=../../dist/even.26188efa.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-107434487-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=../../js/typed.js@2.0.9></script><script src=../../js/typedjs.shortcode.js></script></body></html>